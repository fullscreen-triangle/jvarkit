package com.github.lindenb.jvarkit.tools.bcftoolsmergebest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.github.lindenb.jvarkit.jcommander.OnePassVcfLauncher;
import com.github.lindenb.jvarkit.lang.StringUtils;
import com.github.lindenb.jvarkit.util.JVarkitVersion;
import com.github.lindenb.jvarkit.util.jcommander.Program;
import com.github.lindenb.jvarkit.util.log.Logger;

import htsjdk.variant.variantcontext.Genotype;
import htsjdk.variant.variantcontext.GenotypeBuilder;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.VariantContextBuilder;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.vcf.VCFHeader;
import htsjdk.variant.vcf.VCFIterator;
/**
BEGIN_DOC

END_DOC
*/
@Program(name="bcftoolsmergebest",
description="Scan a VCF file generated by 'bcftools merge', identify duplicate samples, keep the best",
keywords={"merge","vcf","bcftools"},
creationDate="20240604",
modificationDate="20240604",
jvarkit_amalgamion = true
)
public class BCFToolsMergeBest extends OnePassVcfLauncher {
	private static final Logger LOG = Logger.build(BCFToolsMergeBest.class).make();

	private static class Sample {
		final String sn;
		final Set<String> aliases = new  HashSet<>();
		Sample(final String sn) {
			this.sn = sn;
			this.aliases.add(sn);
			}
		}
	
private boolean isBetter(Genotype g1,Genotype g2) {
	if(g1.hasGQ() && g2.hasGQ()) {
		return g1.getGQ() > g2.getGQ();
		}
	if(g1.hasDP() && g2.hasDP()) {
		return g1.getDP() > g2.getDP();
		}
	if(g1.hasPL() && g2.hasPL()) {
		return Arrays.stream(g1.getPL()).max().orElse(0) > Arrays.stream(g2.getPL()).max().orElse(0);
		}
	return true;
	}
	
private Genotype findBest(final List<Genotype> array) {
	if(array.size()==1)  return array.get(0);
	Genotype best=array.get(0);
	for(int i=1;i< array.size();i++) {
		if(isBetter(array.get(i),best)) {
			best=array.get(i); 
			}
		}
	return best;
	}
	
@Override
protected Logger getLogger() {
	return LOG;
	}

@Override
protected int doVcfToVcf(String inputName, VCFIterator iterin, VariantContextWriter out) {
	final VCFHeader header = iterin.getHeader();
	final List<String> samples0 =header.getGenotypeSamples();
	final Map<String,Sample> hashmap = new HashMap<>(samples0.size()); 
	
	final Pattern pattern = Pattern.compile("^\\d+\\:.+");
	
	// sample without ambiguity
	for(final String sn:samples0 ) {
		if(pattern.matcher(sn).matches()) continue;
		hashmap.put(sn,new  Sample(sn));
		}
	// sample with ambiguity
	for(final String sn:samples0 ) {
		if(!pattern.matcher(sn).matches()) continue;
		final String sn2 = StringUtils.substringAfter(sn, ":");
		Sample sample = hashmap.get(sn2);
		if(sn2==null) {
			sample = new  Sample(sn2);
			hashmap.put(sn2,sample);
			}
		sample.aliases.add(sn);
		}
	
	
	final VCFHeader header2 = new VCFHeader(
			header.getMetaDataInInputOrder(),
			hashmap.keySet()
			);
	JVarkitVersion.getInstance().addMetaData(this, header2);
	
	out.writeHeader(header2);
	final List<Genotype> genotypes = new ArrayList<>(hashmap.size());
	while(iterin.hasNext()) {
		final VariantContext ctx = iterin.next();
		final VariantContextBuilder vcb = new VariantContextBuilder(ctx);
		for(final Sample sn: hashmap.values()) {
			final Genotype g = findBest(sn.aliases.stream().
				map(SN->ctx.getGenotype(SN)).
				collect(Collectors.toList()));
			genotypes.add(new GenotypeBuilder(g).name(sn.sn).make());
			}
		vcb.genotypes(genotypes);
		out.add(vcb.make());
		}
	return 0;
	}


	public static void main(String[] args) {
		new BCFToolsMergeBest().instanceMainWithExit(args);
	}

}
